from msilib import make_id
from msilib.schema import Control
import os
from os.path import isfile, join
from PIL import Image, ImageDraw, ImageFont

vompath = 'C:\\Users\\Thomas.Henshaw001\\Development\\montague\\2022_Ben\\ML_amp timecourse'

#Takes a path as a string and returns the paths of all the files within the directory it points to, filtered for .tiff files
def listify(mypath):
    listdir = []
    for root, dirs, files in os.walk(os.path.abspath(mypath)):
        for file in files:
            listdir.append(os.path.join(root, file))
    justpics = []
    for dirs in listdir:
        if dirs.endswith('tiff'):
            justpics.append(dirs)
    return justpics

#Takes a list (as generated by listify) of paths and breaks them down into lists of lists containing the full file structure leading into each file
def breakdown(picslist):
    breakdownList = []
    for imgpath in picslist:
        new = imgpath.split('\\')[-4:-1]
        new.append(imgpath)
        breakdownList.append(new)
    return breakdownList

#Takes a list (as generated by breakdown) and generates a branching nested dictionary assuming four items per list, could be done recursively(?)
def dictify(breakdownlist):
    dirdict = {}
    for k, v, a, d in breakdownlist:
        if k not in dirdict:
            dirdict[k] = {v:{a:[d]}}
        elif v not in dirdict[k]:
            dirdict[k][v] = {a:[d]}
        elif a not in dirdict[k][v]:
            dirdict[k][v][a] = [d]
        else:
            dirdict[k][v][a].append(d)
    return dirdict


#Takes unparsed list of files, unit time, and experimental subgroup and returns the details about the smallest image in a dictionary
def smallestImgDim(breakdownlist):
    data = {'min_width':0,'min_height':0,'min_pix_ct':0,'file_path':""}
    for k, v, a, d in breakdownlist:
        with Image.open(d) as img:
            width, height = img.size
            if width*height > data['min_pix_ct'] or data['min_pix_ct'] == 0:
                data['min_width'] = width
                data['min_height'] = height
                data['min_pix_ct'] = width*height
                data['file_path'] = d
    return data

#Takes return from previous function and the path of the image being resized and returns the smaller image, not actually used in this version of the code
def ensmallenImg(smallestimgdim, newpath):
    image = Image.open(newpath)
    smallimage = image.resize((smallestimgdim['min_width'],smallestimgdim['min_height']))
    return smallimage

#Takes parsed dictionary and returns a dictionary for the max number of files in each secondary subgroup, this determines the height of the y-axis as it relates to the grid
def getMaxImages(breakdowndict):
    maximgdict = {}
    groupslist = list(breakdowndict.keys())
    for key in groupslist:
        maximgdict.update(breakdowndict[key])
    maxbyweek = {}
    nameslist = list(maximgdict.keys())
    for names in nameslist:
        for items in maximgdict[names]:
            if items not in maxbyweek:
                maxbyweek[items] = [len(maximgdict[names][items])]
            else:
                maxbyweek[items].append(len(maximgdict[names][items]))
    for weeks in maxbyweek:
        maxentry = {weeks: max(maxbyweek[weeks])}
        maxbyweek.update(maxentry)
    return maxbyweek


#Takes dictionary from previous function and a string that represents the text to be added to the image, used to make side-headers for each subgroup
def makeHeader(dimensions, name):
    width = dimensions['min_width']
    height = dimensions['min_height']

    fontsize = 1
    myfont = ImageFont.truetype("arial.ttf", fontsize)
    background = Image.new("RGB", (width, height), color = 'black')
    img_fraction = height / width
    if img_fraction > 1:
        img_fraction = width/height
    while myfont.getlength(name)< img_fraction*background.size[0]:
        myfont = ImageFont.truetype("arial.ttf", fontsize)
        fontsize += 1
    write = ImageDraw.Draw(background)
    y = myfont.getbbox(name)[3]
    x = myfont.getbbox(name)[2]
    text_x = (width - x) / 2
    text_y = (height - y) / 2
    write.text((text_x, text_y), name, fill = "white", font = myfont)
    return background


#Generates the first column of the montage grid, leaving two spaces at the top for the subgroup headers. The height of each y-axis subgroup is determined by the maximum number of files present in that subgroup. The order of the subgroup is determined alphabetically
def makeYLegend(dirpath):
    dirlist = breakdown(listify(dirpath))
    dirdict = dictify(dirlist)
    heightbyweek = getMaxImages(dirdict)
    dimensions = smallestImgDim(dirlist)
    unit_height = dimensions['min_height']
    height = (sum(heightbyweek.values()) + 2)*dimensions['min_height']
    sidebar = Image.new('RGB', (dimensions['min_width'], height), color = 'black')
    y_offset = 2 * unit_height
    for weeks in sorted(heightbyweek.keys()):
        dimensions['min_height'] = heightbyweek[weeks] * unit_height
        weekheader = makeHeader(dimensions, weeks)
        sidebar.paste(weekheader, (0, y_offset))
        y_offset += unit_height * heightbyweek[weeks]
    return sidebar


#Takes root path of a three part directory and returns an image and saves it for an indeterminately large four part directory
def makeColumns(dirpath):
    dirlist = breakdown(listify(dirpath))
    dirdict = dictify(dirlist)
    heightbyweek = getMaxImages(dirdict)
    dimensions = smallestImgDim(dirlist)
    unit_height = dimensions['min_height']
    unit_width = dimensions['min_width']
    height = (sum(heightbyweek.values()) + 2) * unit_height
    width = 1
    for i in dirdict.keys():
        width += len(dirdict[i].keys())
    width = width * dimensions['min_width']
    height = (sum(heightbyweek.values()) + 2) * unit_height
    x_offset = 0
    y_offset = 0
    graphcanvas = Image.new('RGB', (width, height), 'black')
    graphcanvas.paste(makeYLegend(dirpath), (x_offset, y_offset))
    x_offset = unit_width
    for groups in sorted(dirdict.keys()):
        groupheaderdimensions = {
            'min_width' : len(dirdict[groups].keys())*unit_width,
            'min_height' : unit_height
        }
        groupheader = makeHeader(groupheaderdimensions, groups)
        graphcanvas.paste(groupheader, (x_offset, y_offset))
        y_offset += unit_height
        print("loop a")
        for animals in sorted(dirdict[groups].keys()): #Makes leading header for animal column
            animalheader = makeHeader(dimensions, animals)
            graphcanvas.paste(animalheader, (x_offset, y_offset))
            y_offset += unit_height
            print("loop b")
            for weeks in sorted(dirdict[groups][animals]):
                print("loop c")
                for files in sorted(dirdict[groups][animals][weeks]):
                    newimg = Image.open(files)
                    graphcanvas.paste(newimg, (x_offset, y_offset))
                    y_offset += unit_height
                    print("loop d")
                snaps = len(dirdict[groups][animals][weeks])
                while snaps < heightbyweek[weeks]:
                    snaps += 1
                    y_offset += unit_height
            y_offset = unit_height
            x_offset += unit_width
        y_offset = 0
    graphcanvas.show()


dirlist = breakdown(listify(vompath))
dirdict = dictify(dirlist)
heightbyweek = getMaxImages(dirdict)
dimensions = smallestImgDim(dirlist)
makeColumns(vompath)


